/////////////////////////////////////////////////////////////////////////////
// Name:      CNinja
// Purpose:   Class for creating/maintaining *.ninja files for use by ninja.exe
// Author:    Ralph Walden
// Copyright: Copyright (c) 2002-2019 KeyWorks Software (Ralph Walden)
// License:   Apache License (see ../LICENSE)
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#include <ttfile.h>     // ttCFile
#include <ttenumstr.h>  // ttCEnumStr
#include <ttcwd.h>      // ttCCwd

#include "ninja.h"     // CNinja
#include "parsehhp.h"  // CParseHHP
#include "verninja.h"  // CVerMakeNinja
#include "funcs.h"     // List of function declarations

const char* aCppExt[] = { ".cpp", ".cxx", ".cc", nullptr };

CNinja::CNinja(const char* pszNinjaDir)
    : CSrcFiles(pszNinjaDir)
{
#if !defined(NDEBUG)  // Starts debug section.
    ttASSERT(ReadFile());
#else
    if (!ReadFile())
        return;
#endif
    m_bForceWrite = false;

    CVerMakeNinja verSrcFiles;
    m_bInvalidVersion = verSrcFiles.IsSrcFilesNewer(GetMajorRequired(), GetMinorRequired(), GetSubRequired());

    if (!GetProjectName())
    {
        ttCStr cszCwd;
        cszCwd.GetCWD();
        char* pszTmp = (char*) cszCwd.FindLastSlash();
        if (!pszTmp[1])  // if path ends with a slash, remove it -- we need that last directory name
            *pszTmp = 0;

        char* pszProj = ttFindFilePortion(cszCwd);
        if (ttIsSameStrI(pszProj, "src"))  // Use the parent folder for the root if the current directory is "src"
        {
            pszTmp = (char*) cszCwd.FindLastSlash();
            if (pszTmp)
            {
                *pszTmp = 0;  // remove the last slash and filename, forcing the directory name above to be the
                              // "filename"
                pszProj = ttFindFilePortion(cszCwd);
            }
        }
        UpdateOption(OPT_PROJECT, pszProj);
    }

    m_lstRcDependencies.SetFlags(ttCList::FLG_URL_STRINGS);

    if (m_cszRcName.IsNonEmpty())
        FindRcDependencies(m_cszRcName);

    const char* pszEnv = getenv("TTBLD_CFLAGS");
    if (pszEnv)
    {
        ttCStr csz;
        if (GetOption(OPT_CFLAGS_CMN))
        {
            csz = GetOption(OPT_CFLAGS_CMN);
            csz += " ";
        }
        csz += pszEnv;
        UpdateOption(OPT_CFLAGS_CMN, (char*) csz);
    }

    ProcessBuildLibs();
}

static const char* aszCompilerPrefix[] = {
    "msvc_",
    "clang_",
    "gcc_",
};

bool CNinja::CreateBuildFile(GEN_TYPE gentype, CMPLR_TYPE cmplr)
{
    ttCFile file;
    m_pkfOut = &file;
    m_gentype = gentype;

    // Note that resout goes to the same directory in all builds. The actual filename will have a 'D' appended for
    // debug builds. Currently, 32 and 64 bit builds of the resource file are identical.

    ttCStr cszResOut("resout = ");
    cszResOut += GetBldDir();
    cszResOut.AddTrailingSlash();
    cszResOut.AppendFileName("res");

    ttCStr cszBuildDir("builddir = ");
    cszBuildDir += GetBldDir();

    ttCStr cszOutDir("outdir = ");
    cszOutDir += GetBldDir();
    cszOutDir.AddTrailingSlash();

    m_cszScriptFile = GetBldDir();
    m_cszScriptFile.backslashestoforward();
    if (m_cszScriptFile.back() != '/')
        m_cszScriptFile.push_back('/');

    switch (gentype)
    {
        case GEN_DEBUG:
            cszOutDir += aszCompilerPrefix[cmplr];
            cszOutDir += "Debug";
            m_cszScriptFile += aszCompilerPrefix[cmplr];
            m_cszScriptFile += "dbg.ninja";
            break;

        case GEN_RELEASE:
        default:
            cszOutDir += aszCompilerPrefix[cmplr];
            cszOutDir += "Release";
            m_cszScriptFile += aszCompilerPrefix[cmplr];
            m_cszScriptFile += "rel.ninja";
            break;
    }

    file.SetUnixLF();  // WARNING!!! NINJA doesn't allow \r characters (or \t for that matter)
    file.printf("# WARNING: This file is auto-generated by %s.\n# Changes you make will be lost if it is "
                "auto-generated again!\n\n",
                txtVersion);

    // REVIEW: [KeyWorks - 11-19-2019] We don't write any new features, could probably state 1.0 and it would work.
    file.WriteEol("ninja_required_version = 1.8\n");
    file.WriteEol(cszBuildDir);

    file.WriteEol(cszOutDir);
    file.WriteEol(cszResOut);

    file.WriteEol();

    // Figure out the filenames to use for the source and output for a precompiled header

    if (GetPchHeader())
    {
        m_cszPCH = GetProjectName();
        m_cszPCH.ChangeExtension(".pch");

        m_cszCPP_PCH = GetPchCpp();
        m_cszPCHObj = ttFindFilePortion(m_cszCPP_PCH);
        m_cszPCHObj.ChangeExtension(".obj");

        if (!ttFileExists(m_cszCPP_PCH))
        {
            ttCStr cszErrorMsg;
            cszErrorMsg.printf(
                "No C++ source file found that matches %s -- precompiled header will not build correctly.\n",
                GetPchHeader());
            puts(cszErrorMsg);
        }
    }

    if (cmplr == CMPLR_MSVC || cmplr == CMPLR_CLANG)
    {
        msvcWriteCompilerComments(cmplr);
        msvcWriteCompilerFlags(cmplr);
        msvcWriteCompilerDirectives(cmplr);
        msvcWriteRcDirective(cmplr);
        msvcWriteMidlDirective(cmplr);
        msvcWriteLibDirective(cmplr);
        msvcWriteLinkDirective(cmplr);
    }

    // Issue #80

    // If the project has a .idl file, then the midl compiler will create a matching header file that will be
    // included in one or more source files. If the .idl file changes, or the header file doesn't exist yet, then
    // we need to run the midl compiler before compiling any source files. If we knew ahead of time which source
    // files included the header file, then we could create a dependency. However, that would essentially require
    // an accurate C/C++ preprocessor to run on every source file which is far beyond the scope of this project.
    // Instead, we add the dependency to the precompiled header if there is one, and if not, we add the dependency
    // to every source file. Unfortunately that does mean that every time the .idl file changes, then every source
    // file will get rebuilt whether or not a particular source file actually uses the generated header file.

    if (GetPchHeader())
    {
        file.printf("build $outdir/%s: compilePCH %s", (char*) m_cszPCHObj, (char*) m_cszCPP_PCH);
        if (m_lstIdlFiles.GetCount())
        {
            file.WriteEol(" | $");
            size_t pos;
            ttCStr cszHdr;
            for (pos = 0; pos < m_lstIdlFiles.GetCount() - 1; ++pos)
            {
                cszHdr = m_lstIdlFiles[pos];
                cszHdr.ChangeExtension(".h");
                file.printf("  %s $\n", (char*) cszHdr);
            }
            cszHdr = m_lstIdlFiles[pos];
            cszHdr.ChangeExtension(".h");
            file.printf("  %s", (char*) cszHdr);  // write the last one without the trailing pipe
        }
        file.WriteEol("\n");
    }

    // Write the build rules for all source files

    for (size_t iPos = 0; iPos < GetSrcFileList()->GetCount(); iPos++)
    {
        ttCStr cszFile(ttFindFilePortion(GetSrcFileList()->GetAt(iPos)));
        if (!ttStrStrI(cszFile, ".c") ||
            (m_cszCPP_PCH.IsNonEmpty() &&
             ttIsSameStrI(cszFile, m_cszCPP_PCH)))  // we already handled resources and pre-compiled headers
            continue;                               // we already handled this
        cszFile.ChangeExtension(".obj");

        if (m_cszPCHObj.IsNonEmpty())  // we add m_cszPCHObj so it appears as a dependency and gets compiled, but
                                       // not linked to
            file.printf("build $outdir/%s: compile %s | $outdir/%s\n\n", (char*) cszFile,
                        GetSrcFileList()->GetAt(iPos), (char*) m_cszPCHObj);
        else
        {
            // We get here if we don't have a precompiled header. We might have .idl files, which means we're going
            // to need to add all the midl-generated header files as dependencies to each source file. See issue
            // #80 for details.

            file.printf("build $outdir/%s: compile %s", (char*) cszFile, GetSrcFileList()->GetAt(iPos));
            if (m_lstIdlFiles.GetCount())
            {
                file.WriteEol(" | $");
                size_t pos;
                ttCStr cszHdr;
                for (pos = 0; pos < m_lstIdlFiles.GetCount() - 1; ++pos)
                {
                    cszHdr = m_lstIdlFiles[pos];
                    cszHdr.ChangeExtension(".h");
                    file.printf("  %s $\n", (char*) cszHdr);
                }
                cszHdr = m_lstIdlFiles[pos];
                cszHdr.ChangeExtension(".h");
                file.printf("  %s", (char*) cszHdr);  // write the last one without the trailing pipe
            }
            file.WriteEol("\n");
        }
    }

    // Write the build rule for the resource compiler if an .rc file was specified as a source

    ttCStr cszRes;
    if (ttFileExists(GetRcFile()))
    {
        cszRes = GetRcFile();
        cszRes.RemoveExtension();
        cszRes += ((m_gentype == GEN_DEBUG) ? "D.res" : ".res");
        cszRes.ChangeExtension(".res");
        file.printf("build $resout/%s: rc %s", (char*) cszRes, GetRcFile());

        if (GetRcDepList()->GetCount())
            file.WriteStr(" |");
        for (size_t nPos = 0; nPos < GetRcDepList()->GetCount(); nPos++)
        {
            file.WriteStr(" $\n  ");
            file.WriteStr(GetRcDepList()->Get(nPos));
        }
        file.WriteEol("\n");
    }

    // Write the final build rules to complete the project

    if (cmplr == CMPLR_MSVC || cmplr == CMPLR_CLANG)
    {
        msvcWriteMidlTargets(cmplr);
        msvcWriteLinkTargets(cmplr);
    }

    if (!ttDirExists(GetBldDir()))
    {
        if (!ttCreateDir(GetBldDir()))
        {
            ttCStr cszMsg;
            cszMsg.printf(_("Unable to create or write to %s"), GetBldDir());
            AddError(cszMsg);
            return false;
        }
    }

    if (m_bForceWrite)
        return file.WriteFile(m_cszScriptFile.c_str());

    ttCFile fileOrg;
    if (fileOrg.ReadFile(m_cszScriptFile.c_str()))
    {
        if (strcmp(fileOrg, file) == 0)  // Only write the build script if something changed
            return false;
        else if (m_dryrun.IsEnabled())
        {
            m_dryrun.NewFile(m_cszScriptFile.c_str());
            m_dryrun.DisplayFileDiff(fileOrg, file);
            return false;  // because we didn't write anything
        }
    }

    if (!file.WriteFile(m_cszScriptFile.c_str()))
    {
        std::string str(_("Unable to create or write to") + m_cszScriptFile + '\n');
        AddError(str.c_str());
        return false;
    }

    return true;
}

void CNinja::AddDependentLibrary(const char* pszLib, GEN_TYPE gentype)
{
    ttCStr cszLib(pszLib);
    if (!ttStrStrI(pszLib, ".lib"))
        cszLib += (gentype == GEN_DEBUG ? "D.lib" : ".lib");

    m_pkfOut->WriteChar(CH_SPACE);
    m_pkfOut->WriteStr(cszLib);
}

void CNinja::ProcessBuildLibs()
{
    if (GetBuildLibs())
    {
        ttCEnumStr enumLib(ttFindNonSpace(GetBuildLibs()), ';');

        while (enumLib.Enum())
        {
            ttCCwd cwdSave;  // Saves the current directory, restores it when we go out of scope.

            // Change to the directory that should contain a .srcfiles.yaml and read it

            if (!ttChDir(enumLib))
            {
                ttCStr cszMsg;
                cszMsg.printf(_("The library source directory %s specified in BuildLibs: does not exist.\n"),
                              (char*) enumLib);
                AddError(cszMsg);
                continue;
            }

            // The current directory may just be the name of the library, but not necessarily where srcfiles is
            // located.

            ttCStr cszBuildPath(enumLib);
            ttCStr cszBuildFile(cszBuildPath);  // LocateSrcFiles will update this
            if (LocateSrcFiles(&cszBuildFile))
            {
                char* pszTmp = ttFindFilePortion(cszBuildFile);
                char  ch = *pszTmp;
                *pszTmp = 0;
                wxSetWorkingDirectory(cszBuildFile.c_str());
                *pszTmp = ch;
            }

            else
            {
                for (;;)  // empty for loop that we break out of as soon as we find a srcfiles file to use
                {
                    if (ttDirExists("src"))
                    {
                        ttChDir("src");
                        if (LocateSrcFiles(&cszBuildFile))
                        {
                            cszBuildPath.AppendFileName("src");
                            break;
                        }
                        else
                            ttChDir("..");
                    }

                    if (ttDirExists("source"))
                    {
                        ttChDir("source");
                        if (LocateSrcFiles(&cszBuildFile))
                        {
                            cszBuildPath.AppendFileName("source");
                            break;
                        }
                        else
                            ttChDir("..");
                    }

                    /*
                        It's unusual, but possible for there to be a sub-directory with the same name as the root
                        directory:

                        foo
                            foo -- src for foo.lib
                            bar -- src for bar.lib
                            app -- src for some related app

                    */

                    if (ttDirExists(ttFindFilePortion(enumLib)))
                    {
                        ttChDir(ttFindFilePortion(enumLib));
                        if (LocateSrcFiles(&cszBuildFile))
                        {
                            cszBuildPath.AppendFileName(ttFindFilePortion(enumLib));
                            break;
                        }
                        else
                            ttChDir("..");
                    }

                    // Any further directory searches should go above this -- once we get here, we can't find a
                    // .srcfiles.yaml. We go ahead and break out of the loop. cSrcFiles.ReadFile() will fail --
                    // we'll use whatever error reporting (if any) it uses for a file that cannot be found or read.

                    break;
                }
            }

            // We've actually changed to the directory containing the .srcfiles.yaml, so CSrcFiles doesn't actually
            // need the filename. However, if an error occurs, we need to indicate where the .srcfiles.yaml file is
            // that had the problem.

            CSrcFiles cSrcFiles;
            cSrcFiles.SetReportingFile(cszBuildFile);
            if (cSrcFiles.ReadFile())
            {
                ttCStr cszCurDir;
                cszCurDir.GetCWD();
                ttCStr cszRelDir;
                ttConvertToRelative(cwdSave, cszCurDir, cszRelDir);
                m_dlstTargetDir.Add(cSrcFiles.GetProjectName(), cszRelDir);
            }

            const char* pszLib = cSrcFiles.GetTargetDebug();
            if (pszLib)
            {
                ttCStr cszLibDir;
                cszLibDir.GetCWD();
                cszLibDir.AppendFileName(pszLib);
                cszLibDir.FullPathName();
                ttCStr cszLib;
                ttConvertToRelative(cwdSave, cszLibDir, cszLib);
                m_lstBldLibsD += cszLib;
            }

            pszLib = cSrcFiles.GetTargetRelease();
            if (pszLib)
            {
                ttCStr cszLibDir;
                cszLibDir.GetCWD();
                cszLibDir.AppendFileName(pszLib);
                cszLibDir.FullPathName();
                ttCStr cszLib;
                ttConvertToRelative(cwdSave, cszLibDir, cszLib);
                m_lstBldLibsR += cszLib;
            }
        }
    }
}
